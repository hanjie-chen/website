x-logging: &default-logging
  driver: json-file
  options:
    max-size: "1m"
    max-file: "5"

services:
  # pull github articles repo once a day
  articles-sync:
    container_name: articles-sync
    # Production image is built/pushed by CI to GHCR.
    # Local development build can be re-enabled in compose.dev.yml.
    image: ghcr.io/hanjie-chen/website-articles-sync:latest
    volumes:
      - source_md_articles:/articles/src:rw
    environment:
      - GITHUB_REPO=https://github.com/hanjie-chen/PersonalArticles.git
      - SOURCE_ARTICLES_DIRECTORY=/articles/src
      - REPO_BRANCH=main
      - WEB_APP_REINDEX_URL=http://web-app:5000/internal/reindex
      - REIMPORT_ARTICLES_TOKEN=${REIMPORT_ARTICLES_TOKEN}
    healthcheck:
      test:
        [
          "CMD-SHELL",
          "[ -d /articles/src/.git ] && pidof crond >/dev/null",
        ]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 90s
    restart: unless-stopped
    logging: *default-logging
  # flask web app container
  web-app:
    container_name: web-app
    # Production image is built/pushed by CI to GHCR.
    # Local development build can be re-enabled in compose.dev.yml.
    image: ghcr.io/hanjie-chen/website-web-app:latest
    volumes:
      - rendered_html_articles:/articles/rendered
      - source_md_articles:/articles/src:ro
      # Persist Flask instance folder so sqlite DB survives container recreation.
      - webapp_instance:/app/instance
    environment:
      - SOURCE_ARTICLES_DIRECTORY=/articles/src
      - RENDERED_ARTICLES_DIRECTORY=/articles/rendered
      - FLASK_APP=app.py
      - APP_ENV=production
      - REIMPORT_ARTICLES_TOKEN=${REIMPORT_ARTICLES_TOKEN}
    healthcheck:
      test:
        [
          "CMD",
          "python",
          "-c",
          "import urllib.request; urllib.request.urlopen('http://127.0.0.1:5000//articles', timeout=3)",
        ]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 30s
    restart: unless-stopped
    logging: *default-logging
  # reserve proxy
  nginx-modsecurity:
    image: owasp/modsecurity-crs:nginx-alpine
    container_name: nginx-modsecurity
    ports:
      - "80:80"
      - "443:443"
    healthcheck:
      test: ["CMD-SHELL", "curl -fsS http://localhost/ || exit 1"]
      interval: 30s
      timeout: 5s
      retries: 3
    volumes:
      - ./nginx-modsecurity/conf.d/default.conf:/etc/nginx/templates/conf.d/default.conf.template
      - ./nginx-modsecurity/.htpasswd:/etc/nginx/.htpasswd:ro # load dozzle panel usr-pwd
      # Dev HTTPS only: self-signed cert/key mount.
      # Replace with Let's Encrypt cert path when moving to public production.
      - ./nginx-modsecurity/ssl:/etc/nginx/ssl:ro
      - rendered_html_articles:/usr/share/nginx/html/rendered-articles
    depends_on:
      - web-app
    environment:
      - MODSEC_AUDIT_LOG=/var/log/nginx/modsec-audit.log
    restart: unless-stopped
    logging: *default-logging
  # logs ui
  dozzle:
    image: amir20/dozzle:latest
    container_name: dozzle
    environment:
      - DOZZLE_BASE=/web-log # set url path
      - DOZZLE_NO_ANALYTICS=true # don't send data outside
    # offical inline health check command
    healthcheck:
      test: ["CMD", "/dozzle", "healthcheck"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 10s
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
    restart: unless-stopped
    logging: *default-logging

volumes:
  source_md_articles: # source markdown files volume
  rendered_html_articles: # the html files volme which rendered form source markdown file
  webapp_instance: # sqlite DB (Flask instance folder) volume
